# Docker Structure Documentation

## Overview
This document outlines the Docker implementation for the task manager project. The implementation consists of five main components:
1. **Frontend**: React application with TypeScript, served via Nginx
2. **Backend**: Express server with TypeScript
3. **PostgreSQL Database**: Persistent relational database service
4. **RabbitMQ Message Broker**: For asynchronous communication and task queuing
5. **Docker Compose**: Orchestrates all services

## Directory Structure
```
.
├── frontend/          # React application
│   ├── Dockerfile     # Frontend Dockerfile (multi-stage build)
│   └── ...            # React project files
├── backend/           # Express server
│   ├── Dockerfile     # Backend Dockerfile
│   └── ...            # Backend project files
├── docs/              # Documentation
│   └── docker-structure.md  # This document
└── docker-compose.yml # Docker Compose configuration
```

## Docker Compose Configuration
### `docker-compose.yml`
```yaml
version: '3.8'

services:
  frontend:
    build:
      context: .
      dockerfile: frontend/Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - frontend:/app
    environment:
      - CHOKIDAR_USEPOLLING=true

  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile
    ports:
      - "4000:4000"
    volumes:
      - backend:/app
    environment:
      - CHOKIDAR_USEPOLLING=true
      - DB_HOST=db
      - DB_USER=postgres
      - DB_PASSWORD=postgres
      - RABBITMQ_HOST=rabbitmq
      - RABBITMQ_USER=guest
      - RABBITMQ_PASSWORD=guest

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: task_manager
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  rabbitmq:
    image: rabbitmq:3-management-alpine
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

volumes:
  frontend:
  backend:
  db_data:
  rabbitmq_data:
```

#### Key Points:
- **Ports**:
  - Frontend: `3000`
  - Backend API: `4000`
  - PostgreSQL: `5432`
  - RabbitMQ: `5672` (AMQP), `15672` (Management UI)
- **Volumes**:
  - Persistent volumes for frontend/backend source code and build artifacts
  - Database and message broker data persistence (`db_data`, `rabbitmq_data`)
- **Environment Variables**:
  - `CHOKIDAR_USEPOLLING=true`: Enables filesystem watching in containers
  - Backend connection strings for PostgreSQL (`DB_HOST`, etc) and RabbitMQ

---

## Frontend Dockerfile
### `frontend/Dockerfile`
```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY frontend/package.json frontend/package-lock.json ./

RUN npm install

COPY frontend/public ./public
COPY frontend/src ./src

RUN ls -la src

RUN npm run build

FROM nginx:alpine

COPY --from=0 /app/build /usr/share/nginx/html

CMD ["nginx", "-g", "daemon off;"]
```

#### Build Process:
1. **Build Stage** (`node:18-alpine`):
   - Sets working directory to `/app`
   - Copies `package.json` and `package-lock.json` for dependency installation
   - Installs dependencies via `npm install`
   - Copies `public` and `src` directories from the host (using explicit `frontend/` prefix to ensure correct build context)
   - Runs `npm run build` to generate production-ready static files in `/app/build`
   - Includes diagnostic `RUN ls -la src` to verify source files are present

2. **Runtime Stage** (`nginx:alpine`):
   - Copies build artifacts from the build stage (`COPY --from=0 /app/build /usr/share/nginx/html`)
   - Starts Nginx (`CMD ["nginx", "-g", "daemon off;"]`)

#### Result:
- Final image size is minimized by using a lightweight Nginx runtime after Node.js build stage
- Static files generated by React are served via Nginx for optimal performance

---

## Backend Dockerfile
### `backend/Dockerfile`
```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY backend/package.json backend/package-lock.json ./

RUN npm install

COPY backend/tsconfig.json ./

COPY backend/src ./src

RUN npm run build
RUN ls -la

CMD ["node", "dist/index.js"]
```

#### Build Process:
1. **Base Image**: `node:18-alpine`
2. **Working Directory**: `/app`
3. **Dependency Installation**:
   - Copies `package.json` and `package-lock.json`
   - Runs `npm install` to install project dependencies
4. **Source Code Copy**:
   - Copies `tsconfig.json` for TypeScript configuration
   - Copies entire `src/` directory
5. **Build Step**:
   - Executes `npm run build` which triggers TypeScript compilation (`tsc`) to `./dist`
   - Includes diagnostic `RUN ls -la` to verify build output
6. **Runtime**:
   - Starts the backend server using compiled JavaScript (`CMD ["node", "dist/index.js"]`)

#### Result:
- TypeScript source is transpiled to JavaScript during build
- Runtime uses minimal Alpine Linux image for security and size efficiency
- Built files are placed in `dist/` directory at root level, matching `tsconfig.json` configuration

---

## Implementation Notes
1. **TypeScript Configuration**:
   - Both frontend and backend use TypeScript. `tsconfig.json` files in each directory define compilation options.
   
2. **Volume Mounts for Development**:
   - Docker Compose uses named volumes (`frontend` and `backend`) to mount source code into containers.
   - This enables real-time code changes to be reflected inside containers without rebuilds (when combined with `CHOKIDAR_USEPOLLING`).

3. **Multi-stage Build (Frontend)**:
   - Reduces final image size dramatically by separating build dependencies (Node.js) from runtime environment (Nginx).

4. **Output Directory (Backend)**:
   - TypeScript compiler (`tsc`) outputs compiled JavaScript files to `dist/` directory at project root, which aligns with the `CMD` execution path in Dockerfile.

